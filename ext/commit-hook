#!/usr/bin/env ruby

ENVIRONMENTS = {
  'development' => /puppet\/trunk/,
  'production'  => /puppet\/tags\/GOLD/
}

begin
  require 'mcollective'
rescue LoadError => e
  puts "Please install MCollective on subversion server"
end

include MCollective::RPC

def update_master(environment)
  #Activate our puppet agent
  mc = rpcclient('puppetupdate')
  mc.class_filter /puppetmaster/
  mc.update :environment => environment, :rcs => 'svn'
end

#GOLD_REGEX     = /puppet\/tags\/GOLD/
#TRUNK_REGEX    = /puppet\/trunk/
MANIFEST_REGEX = /\.pp$/

class CommitCmd
  attr_reader :status, :output, :cmd

  def initialize(cmd)
    @cmd    = cmd
    @status = nil
  end

  def run
    @output = `#{@cmd} 2>&1`
    @status = $?
  end
end

repos = ARGV[0]
txn   = ARGV[1]

if repos.nil? or txn.nil?
  puts "Invalid commands"
  exit(1)
end

filelistcmd = CommitCmd.new("/usr/bin/svnlook changed -t #{txn} #{repos}")
filelistcmd.run

if filelistcmd.status.exitstatus != 0
  puts "Error getting change list:"
  puts filelistcmd.output
  exit(1)
end

errors = []

workdir = "/tmp/puppet.commit.#{$$}"
Dir.mkdir(workdir)
ENV["HOME"] = workdir
ENV["RUBYLIB"] = "/path/to/libdir"

filestocleanup = []
filelistcmd.output.split("\n").each do |l|
  op = l[0..3].strip
  f  = l[4..-1].strip
  next if not ["U", "A"].include?(op)

  #Go to next line if we don't match any environment regex
  next unless ENVIRONMENTS.map { |env,regex| regex =~ l ? true : false }.include? true

  next if MANIFEST_REGEX !~ l
  wf = f.gsub("/", ".")
  filestocleanup << wf
  filecatcmd = CommitCmd.new("/usr/bin/svnlook cat -t #{txn} #{repos} #{f} > #{workdir}/#{wf}")
  filecatcmd.run
  if filecatcmd.status.exitstatus != 0
    errors << "Error reading #{f}:\n  #{filecatcmd.output.gsub("\n", "\n  ")}"
    next
  end

  puppetcmd = CommitCmd.new("/usr/scea/puppet/bin/puppet --noop --color=false --parseonly --ignoreimport #{workdir}/#{wf}")
  puppetcmd.run
  if puppetcmd.status.exitstatus != 0
    errors << "Puppet errors in #{f}:\n  #{puppetcmd.output.gsub("\n", "\n  ")}"
    next
  end

end

 # cleanup
 begin
   filestocleanup.each do |f|
     File.unlink("#{workdir}/#{f}")
   end
   Dir.rmdir(workdir)
 rescue StandardError => e
   puts "Error cleaning up: #{e}"
end

# print errors
if not errors.empty?
  puts
  errors.each do |e|
    puts e
  end
  exit(errors.length)
end

#Update puppet masters if necessary
env_array = Array.new
filelistcmd.output.split("\n").each do |l|
  ENVIRONMENTS.each do |env,regex|
    if ( regex =~ l) and (! env_array.include?(env) )
      env_array << env
    end
  end

  env_array.each { |env| update_master env }
end

exit(0)
